<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="HTMLForge - Forge HTML applications with AI assistance. Create and modify single-page web applications using DeepSeek AI.">
    <title>HTMLForge</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <style>
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .loading {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .stream-text {
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: break-word;
            overflow-wrap: break-word;
        }
        .search-replace-block {
            background-color: #f8fafc;
            border-left: 4px solid #3b82f6;
            margin: 1rem 0;
            padding: 1rem;
        }
        .dark .search-replace-block {
            background-color: #1e293b;
            border-left-color: #60a5fa;
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen">
    <!-- Header Section -->
    <header class="bg-white dark:bg-gray-800 shadow-sm border-b border-gray-200 dark:border-gray-700">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center py-6">
                <div class="flex items-center">
                    <div class="flex-shrink-0">
                        <h1 class="text-2xl font-bold text-gray-900 dark:text-white">HTMLForge</h1>
                        <p class="text-sm text-gray-500 dark:text-gray-400">Forge HTML applications with AI assistance</p>
                    </div>
                </div>
                <div class="flex items-center space-x-4">
                    <button id="darkModeToggle" class="p-2 rounded-md text-gray-400 hover:text-gray-500 dark:text-gray-300 dark:hover:text-gray-200">
                        <i data-lucide="moon" class="w-5 h-5"></i>
                    </button>
                    <div class="flex items-center space-x-2">
                        <span id="connectionStatus" class="flex items-center space-x-1">
                            <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                            <span class="text-sm text-gray-500 dark:text-gray-400">Disconnected</span>
                        </span>
                    </div>
                </div>
            </div>
            
            <!-- API Key Input -->
            <div class="pb-6">
                <div class="flex items-center space-x-4">
                    <div class="flex-1 relative">
                        <label for="apiKey" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">DeepSeek API Key</label>
                        <div class="relative">
                            <input type="password" id="apiKey" placeholder="Enter your DeepSeek API key" 
                                   class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white pr-10">
                            <button id="toggleApiKey" class="absolute inset-y-0 right-0 pr-3 flex items-center text-gray-400 hover:text-gray-600 dark:text-gray-300 dark:hover:text-gray-200">
                                <i data-lucide="eye" class="w-4 h-4"></i>
                            </button>
                        </div>
                    </div>
                    <button id="testConnection" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800">
                        Test Connection
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="h-[calc(100vh-200px)] px-4 sm:px-6 lg:px-8 py-8">
        <div class="h-full grid grid-cols-1 lg:grid-cols-12 gap-6">
            <!-- Left Panel: Input and Stream (4 columns on large screens) -->
            <div class="lg:col-span-4 flex flex-col space-y-6 h-full">
                <!-- Input Tab Navigation -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 flex-shrink-0">
                    <div class="border-b border-gray-200 dark:border-gray-700">
                        <nav class="flex space-x-8 px-6" aria-label="Tabs">
                            <button id="createTab" class="tab-button border-b-2 border-blue-500 text-blue-600 dark:text-blue-400 py-4 px-1 text-sm font-medium">
                                <i data-lucide="plus-circle" class="w-4 h-4 inline mr-2"></i>
                                Create New
                            </button>
                            <button id="modifyTab" class="tab-button border-b-2 border-transparent text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-300 py-4 px-1 text-sm font-medium">
                                <i data-lucide="edit" class="w-4 h-4 inline mr-2"></i>
                                Modify Existing
                            </button>
                        </nav>
                    </div>

                    <!-- Create New Tab Content -->
                    <div id="createContent" class="tab-content active p-6">
                        <div class="space-y-4">
                            <div>
                                <label for="createRequirements" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Describe your HTML application
                                </label>
                                <textarea id="createRequirements" rows="8" placeholder="Describe the HTML application you want to create. Be specific about features, styling, and functionality..."
                                          class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white resize-none"></textarea>
                            </div>
                            <button id="generateHTML" class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">
                                <i data-lucide="play" class="w-4 h-4 inline mr-2"></i>
                                Generate HTML
                            </button>
                        </div>
                    </div>

                    <!-- Modify Existing Tab Content -->
                    <div id="modifyContent" class="tab-content p-6">
                        <div class="space-y-4">
                            <!-- Current HTML Status -->
                            <div id="currentHtmlStatus" class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-md p-4 hidden">
                                <div class="flex items-center">
                                    <i data-lucide="code" class="w-5 h-5 text-blue-600 dark:text-blue-400 mr-2"></i>
                                    <div>
                                        <h4 class="text-sm font-medium text-blue-800 dark:text-blue-200">Using Generated HTML</h4>
                                        <p class="text-xs text-blue-600 dark:text-blue-400">Modifying the currently generated HTML application</p>
                                    </div>
                                    <button id="clearCurrentHtml" class="ml-auto text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-200">
                                        <i data-lucide="x" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>

                            <div id="uploadSection">
                                <label for="htmlFile" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Upload HTML File
                                </label>
                                <div class="mt-1 flex justify-center px-6 pt-4 pb-4 border-2 border-gray-300 dark:border-gray-600 border-dashed rounded-md hover:border-gray-400 dark:hover:border-gray-500">
                                    <div class="space-y-1 text-center">
                                        <i data-lucide="upload" class="mx-auto h-8 w-8 text-gray-400"></i>
                                        <div class="flex text-sm text-gray-600 dark:text-gray-400">
                                            <label for="htmlFile" class="relative cursor-pointer bg-white dark:bg-gray-800 rounded-md font-medium text-blue-600 hover:text-blue-500 focus-within:outline-none focus-within:ring-2 focus-within:ring-offset-2 focus-within:ring-blue-500 dark:focus-within:ring-offset-gray-800">
                                                <span>Upload a file</span>
                                                <input id="htmlFile" name="htmlFile" type="file" accept=".html" class="sr-only">
                                            </label>
                                            <p class="pl-1">or drag and drop</p>
                                        </div>
                                        <p class="text-xs text-gray-500 dark:text-gray-400">HTML files only</p>
                                    </div>
                                </div>
                                <div id="uploadedFile" class="mt-2 hidden">
                                    <p class="text-sm text-gray-600 dark:text-gray-400">
                                        <i data-lucide="file" class="w-4 h-4 inline mr-1"></i>
                                        <span id="fileName"></span>
                                    </p>
                                </div>
                            </div>
                            <div>
                                <label for="modifyInstructions" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                                    Modification Instructions
                                </label>
                                <textarea id="modifyInstructions" rows="4" placeholder="Describe what changes you want to make to the HTML file..."
                                          class="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white resize-none"></textarea>
                            </div>
                            <button id="applyChanges" class="w-full px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">
                                <i data-lucide="refresh-cw" class="w-4 h-4 inline mr-2"></i>
                                Apply Changes
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Live Stream Display -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 flex-1 flex flex-col min-h-0 max-h-[50vh]">
                    <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-medium text-gray-900 dark:text-white">Live Stream</h3>
                            <div class="flex items-center space-x-2">
                                <div id="loadingIndicator" class="hidden">
                                    <i data-lucide="loader" class="w-4 h-4 text-blue-500 loading"></i>
                                </div>
                                <span id="characterCount" class="text-sm text-gray-500 dark:text-gray-400">0 characters</span>
                            </div>
                        </div>
                    </div>
                    <div class="p-6 flex-1 min-h-0 overflow-hidden">
                        <div id="streamOutput" class="bg-gray-50 dark:bg-gray-900 border border-gray-200 dark:border-gray-700 rounded-md p-4 h-full overflow-y-auto font-mono text-sm stream-text whitespace-pre-wrap break-words"></div>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Preview and Actions (8 columns on large screens) -->
            <div class="lg:col-span-8 flex flex-col space-y-6 h-full">
                <!-- Preview Area -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 flex-1 flex flex-col min-h-0">
                    <div class="px-6 py-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
                        <div class="flex items-center justify-between">
                            <h3 class="text-lg font-medium text-gray-900 dark:text-white">Preview</h3>
                            <div class="flex items-center space-x-2">
                                <button id="rawHtmlToggle" class="px-3 py-1 text-sm bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600">
                                    Raw HTML
                                </button>
                                <button id="livePreviewToggle" class="px-3 py-1 text-sm bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300 rounded-md hover:bg-blue-200 dark:hover:bg-blue-800">
                                    Live Preview
                                </button>
                                <button id="fullscreenPreview" class="p-1 text-gray-400 hover:text-gray-600 dark:text-gray-300 dark:hover:text-gray-200 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                                    <i data-lucide="maximize" class="w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="p-6 flex-1 min-h-0">
                        <div id="previewContainer" class="border border-gray-200 dark:border-gray-700 rounded-md h-full overflow-hidden">
                            <iframe id="previewFrame" class="w-full h-full border-0" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
                            <textarea id="rawHtmlView" class="w-full h-full border-0 p-4 font-mono text-sm bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-200 resize-none hidden" readonly></textarea>
                        </div>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="bg-white dark:bg-gray-800 rounded-lg shadow-sm border border-gray-200 dark:border-gray-700 p-6 flex-shrink-0">
                    <div class="grid grid-cols-2 lg:grid-cols-5 gap-4">
                        <button id="modifyThis" class="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 focus:outline-none focus:ring-2 focus:ring-orange-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                            <i data-lucide="edit" class="w-4 h-4 inline mr-2"></i>
                            Modify This
                        </button>
                        <button id="downloadHtml" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-lucide="download" class="w-4 h-4 inline mr-2"></i>
                            Download HTML
                        </button>
                        <button id="copyToClipboard" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-lucide="copy" class="w-4 h-4 inline mr-2"></i>
                            Copy to Clipboard
                        </button>
                        <button id="clearOutput" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800">
                            <i data-lucide="trash-2" class="w-4 h-4 inline mr-2"></i>
                            Clear Output
                        </button>
                        <button id="saveToStorage" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800 disabled:opacity-50 disabled:cursor-not-allowed">
                            <i data-lucide="save" class="w-4 h-4 inline mr-2"></i>
                            Save to Storage
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Fullscreen Modal -->
    <div id="fullscreenModal" class="fixed inset-0 bg-black z-50 hidden">
        <div class="flex flex-col h-full">
            <div class="flex items-center justify-between p-4 bg-gray-800 border-b border-gray-600">
                <h3 class="text-lg font-medium text-white">Full Screen Preview</h3>
                <button id="closeFullscreen" class="p-2 text-gray-400 hover:text-white rounded-md hover:bg-gray-700">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div class="flex-1 overflow-hidden">
                <iframe id="fullscreenFrame" class="w-full h-full border-0" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
            </div>
        </div>
    </div>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Global variables
        let currentHtml = '';
        let currentUploadedHtml = '';
        let usingGeneratedHtml = false; // Track if we're modifying generated HTML
        let apiClient = null;
        let streamRenderer = null;
        let htmlProcessor = null;
        let uiManager = null;


        // APIClient class for DeepSeek API communication
        class APIClient {
            constructor() {
                this.apiKey = '';
                this.baseUrl = 'https://api.deepseek.com/v1/chat/completions';
                this.isConnected = false;
            }

            setApiKey(key) {
                this.apiKey = key;
                localStorage.setItem('deepseek_api_key', key);
            }

            async testConnection() {
                try {
                    const response = await fetch(this.baseUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'deepseek-chat',
                            messages: [{ role: 'user', content: 'test' }],
                            max_tokens: 1,
                            stream: false
                        })
                    });

                    this.isConnected = response.ok;
                    return this.isConnected;
                } catch (error) {
                    console.error('Connection test failed:', error);
                    this.isConnected = false;
                    return false;
                }
            }

            async streamRequest(messages, onChunk, onComplete, onError) {
                let fullContent = '';
                let conversationMessages = [...messages];
                let continuationCount = 0;
                const maxContinuations = 3; // Prevent infinite loops
                
                const makeRequest = async (isRetry = false) => {
                    try {
                        const response = await fetch(this.baseUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.apiKey}`
                            },
                            body: JSON.stringify({
                                model: 'deepseek-chat',
                                messages: conversationMessages,
                                max_tokens: 4000,
                                stream: true,
                                temperature: 0.7
                            })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        let currentChunk = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop(); // Keep the last incomplete line

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') {
                                        // Check if output seems incomplete and we haven't exceeded max continuations
                                        if (this.isIncompleteOutput(fullContent) && continuationCount < maxContinuations) {
                                            // Add assistant message and continue
                                            conversationMessages.push({ role: 'assistant', content: fullContent });
                                            conversationMessages.push({ role: 'user', content: 'continue' });
                                            
                                            continuationCount++;
                                            
                                            // Show continuation indicator
                                            onChunk(`\n\n[Auto-continuing generation... (${continuationCount}/${maxContinuations})]\n\n`);
                                            
                                            // Continue after a brief delay
                                            setTimeout(() => makeRequest(true), 1000);
                                            return;
                                        }
                                        
                                        onComplete();
                                        return;
                                    }
                                    try {
                                        const json = JSON.parse(data);
                                        if (json.choices[0].delta.content) {
                                            currentChunk = json.choices[0].delta.content;
                                            fullContent += currentChunk;
                                            onChunk(currentChunk);
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON
                                    }
                                }
                            }
                        }
                    } catch (error) {
                        onError(error);
                    }
                };

                await makeRequest();
            }

            isIncompleteOutput(content) {
                if (!content || content.trim().length < 100) {
                    return true;
                }

                const trimmedContent = content.trim();
                
                // Check for explicit continuation markers
                const continuationMarkers = [
                    /\.{3}$/,
                    /\[continued\]/i,
                    /\[continue\]/i,
                    /\(continued\)/i,
                    /…$/,
                    /\.\.\./,
                    /continues?\.\.\.$/i
                ];

                for (const marker of continuationMarkers) {
                    if (marker.test(trimmedContent)) {
                        return true;
                    }
                }

                // For HTML content, check structural completeness
                if (trimmedContent.includes('<!DOCTYPE') || trimmedContent.includes('<html')) {
                    // Check if major HTML structures are complete
                    const hasDoctype = /<!DOCTYPE\s+html\s*>/i.test(trimmedContent);
                    const hasHtmlOpen = /<html[^>]*>/i.test(trimmedContent);
                    const hasHtmlClose = /<\/html\s*>/i.test(trimmedContent);
                    const hasHeadOpen = /<head[^>]*>/i.test(trimmedContent);
                    const hasHeadClose = /<\/head\s*>/i.test(trimmedContent);
                    const hasBodyOpen = /<body[^>]*>/i.test(trimmedContent);
                    const hasBodyClose = /<\/body\s*>/i.test(trimmedContent);

                    // If HTML document started but not properly closed
                    if (hasHtmlOpen && !hasHtmlClose) {
                        return true;
                    }
                    if (hasHeadOpen && !hasHeadClose) {
                        return true;
                    }
                    if (hasBodyOpen && !hasBodyClose) {
                        return true;
                    }

                    // Check for unclosed script or style tags
                    const scriptMatches = (trimmedContent.match(/<script[^>]*>/gi) || []).length;
                    const scriptCloseMatches = (trimmedContent.match(/<\/script\s*>/gi) || []).length;
                    if (scriptMatches > scriptCloseMatches) {
                        return true;
                    }

                    const styleMatches = (trimmedContent.match(/<style[^>]*>/gi) || []).length;
                    const styleCloseMatches = (trimmedContent.match(/<\/style\s*>/gi) || []).length;
                    if (styleMatches > styleCloseMatches) {
                        return true;
                    }
                }

                // Check if content ends abruptly (incomplete sentence or tag)
                const lastChar = trimmedContent.charAt(trimmedContent.length - 1);
                if (lastChar === '<' || lastChar === '&') {
                    return true;
                }

                // Check for incomplete tags at the end
                const incompleteTagPattern = /<[^>]*$/;
                if (incompleteTagPattern.test(trimmedContent)) {
                    return true;
                }

                return false;
            }
        }

        // StreamRenderer class for real-time text display
        class StreamRenderer {
            constructor(outputElement, characterCountElement) {
                this.outputElement = outputElement;
                this.characterCountElement = characterCountElement;
                this.content = '';
                this.isStreaming = false;
                this.previewUpdateTimeout = null;
            }

            startStream() {
                this.isStreaming = true;
                this.content = '';
                this.outputElement.textContent = '';
                this.updateCharacterCount();
                document.getElementById('loadingIndicator').classList.remove('hidden');
                
                // Disable fullscreen button during streaming
                document.getElementById('fullscreenPreview').disabled = true;
            }

            addChunk(chunk) {
                if (!this.isStreaming) return;
                
                this.content += chunk;
                this.outputElement.textContent = this.content;
                this.updateCharacterCount();
                
                // Auto-scroll to bottom
                this.outputElement.scrollTop = this.outputElement.scrollHeight;
                
                // Update preview less frequently to avoid CPU spikes
                if (!this.previewUpdateTimeout && (this.content.includes('<html') || this.content.includes('<!DOCTYPE'))) {
                    this.previewUpdateTimeout = setTimeout(() => {
                        this.updatePreview();
                        this.previewUpdateTimeout = null;
                    }, 500); // Only update every 500ms during streaming
                }
            }

            endStream() {
                this.isStreaming = false;
                document.getElementById('loadingIndicator').classList.add('hidden');
                
                // Clear any pending preview updates
                if (this.previewUpdateTimeout) {
                    clearTimeout(this.previewUpdateTimeout);
                    this.previewUpdateTimeout = null;
                }
                
                // Extract HTML and update global variable
                const extractedHtml = this.extractHtmlFromContent(this.content);
                currentHtml = extractedHtml || this.content;
                
                // Debug log
                console.log('HTML extraction result:', {
                    originalLength: this.content.length,
                    extractedLength: extractedHtml.length,
                    hasHtml: !!extractedHtml,
                    currentHtmlLength: currentHtml ? currentHtml.length : 0
                });
                
                // Enable fullscreen and modify buttons if we have HTML content
                const fullscreenButton = document.getElementById('fullscreenPreview');
                const modifyButton = document.getElementById('modifyThis');
                if (currentHtml && currentHtml.trim()) {
                    fullscreenButton.disabled = false;
                    modifyButton.disabled = false;
                } else {
                    fullscreenButton.disabled = true;
                    modifyButton.disabled = true;
                }
                
                // Final preview update
                this.updatePreview();
            }

            updateCharacterCount() {
                this.characterCountElement.textContent = `${this.content.length} characters`;
            }

            updatePreview() {
                const previewFrame = document.getElementById('previewFrame');
                const rawHtmlView = document.getElementById('rawHtmlView');
                
                // Extract HTML from the content
                const extractedHtml = this.extractHtmlFromContent(this.content);
                
                // Update raw HTML view with extracted HTML
                rawHtmlView.value = extractedHtml;
                
                // Update iframe preview only if we have valid HTML
                if (extractedHtml.trim()) {
                    try {
                        // Wait for iframe to be ready
                        if (previewFrame.contentDocument || previewFrame.contentWindow) {
                            const doc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                            doc.open();
                            doc.write(extractedHtml);
                            doc.close();
                        } else {
                            // Fallback: use srcdoc attribute
                            previewFrame.srcdoc = extractedHtml;
                        }
                    } catch (error) {
                        console.error('Preview update failed:', error);
                        // Fallback: use srcdoc attribute
                        previewFrame.srcdoc = extractedHtml;
                    }
                }
            }

            extractHtmlFromContent(content) {
                if (!content || typeof content !== 'string') return '';
                
                // First, try to find complete HTML documents
                const completeHtmlPattern = /<!DOCTYPE\s+html[\s\S]*?<\/html\s*>/gi;
                const completeMatches = content.match(completeHtmlPattern);
                if (completeMatches && completeMatches.length > 0) {
                    console.log('Found complete HTML document');
                    return completeMatches[completeMatches.length - 1];
                }
                
                // Try to find HTML tag blocks
                const htmlTagPattern = /<html[\s\S]*?<\/html\s*>/gi;
                const htmlMatches = content.match(htmlTagPattern);
                if (htmlMatches && htmlMatches.length > 0) {
                    console.log('Found HTML tag block');
                    return htmlMatches[htmlMatches.length - 1];
                }
                
                // Look for HTML starting from DOCTYPE or <html>
                let startIndex = content.search(/<!DOCTYPE\s+html/i);
                if (startIndex === -1) {
                    startIndex = content.search(/<html[\s\S]/i);
                }
                
                if (startIndex !== -1) {
                    const htmlContent = content.substring(startIndex);
                    console.log('Found HTML fragment starting at index', startIndex);
                    
                    // If it contains basic HTML structure, return it
                    if (htmlContent.includes('<html') || htmlContent.includes('<!DOCTYPE')) {
                        return htmlContent;
                    }
                }
                
                // As a last resort, if content has HTML tags but no proper structure
                if (content.includes('<') && content.includes('>') && content.length > 100) {
                    console.log('Found HTML-like content, returning as-is');
                    return content;
                }
                
                console.log('No HTML content found');
                return '';
            }

            clear() {
                this.content = '';
                this.outputElement.textContent = '';
                this.updateCharacterCount();
                document.getElementById('rawHtmlView').value = '';
                
                // Disable fullscreen and modify buttons when cleared
                document.getElementById('fullscreenPreview').disabled = true;
                document.getElementById('modifyThis').disabled = true;
                
                // Clear preview
                const previewFrame = document.getElementById('previewFrame');
                try {
                    if (previewFrame.contentDocument || previewFrame.contentWindow) {
                        const doc = previewFrame.contentDocument || previewFrame.contentWindow.document;
                        doc.open();
                        doc.write('');
                        doc.close();
                    } else {
                        previewFrame.srcdoc = '';
                    }
                } catch (error) {
                    console.error('Preview clear failed:', error);
                    previewFrame.srcdoc = '';
                }
            }
        }

        // HTMLProcessor class for SEARCH/REPLACE functionality
        class HTMLProcessor {
            constructor() {
                this.searchReplaceBlocks = [];
            }

            parseSearchReplaceBlocks(content) {
                const blocks = [];
                const searchPattern = /<<<<<<< SEARCH\n([\s\S]*?)\n=======\n([\s\S]*?)\n>>>>>>> REPLACE/g;
                let match;

                while ((match = searchPattern.exec(content)) !== null) {
                    blocks.push({
                        search: match[1],
                        replace: match[2]
                    });
                }

                this.searchReplaceBlocks = blocks;
                return blocks;
            }

            applyChanges(originalHtml, blocks) {
                let modifiedHtml = originalHtml;
                let appliedChanges = 0;

                for (const block of blocks) {
                    const searchText = block.search;
                    const replaceText = block.replace;

                    if (modifiedHtml.includes(searchText)) {
                        modifiedHtml = modifiedHtml.replace(searchText, replaceText);
                        appliedChanges++;
                    }
                }

                return {
                    html: modifiedHtml,
                    appliedChanges: appliedChanges,
                    totalBlocks: blocks.length
                };
            }

            displaySearchReplaceBlocks(blocks) {
                const container = document.getElementById('streamOutput');
                container.innerHTML = '';

                blocks.forEach((block, index) => {
                    const blockElement = document.createElement('div');
                    blockElement.className = 'search-replace-block';
                    blockElement.innerHTML = `
                        <h4 class="font-semibold text-gray-800 dark:text-gray-200 mb-2">Change ${index + 1}</h4>
                        <div class="space-y-2">
                            <div>
                                <span class="text-sm font-medium text-red-600 dark:text-red-400">SEARCH:</span>
                                <pre class="bg-red-50 dark:bg-red-900/20 p-2 rounded text-sm overflow-x-auto"><code>${this.escapeHtml(block.search)}</code></pre>
                            </div>
                            <div>
                                <span class="text-sm font-medium text-green-600 dark:text-green-400">REPLACE:</span>
                                <pre class="bg-green-50 dark:bg-green-900/20 p-2 rounded text-sm overflow-x-auto"><code>${this.escapeHtml(block.replace)}</code></pre>
                            </div>
                        </div>
                    `;
                    container.appendChild(blockElement);
                });
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // UIManager class for tab switching and form handling
        class UIManager {
            constructor() {
                this.currentTab = 'create';
                this.isDarkMode = localStorage.getItem('darkMode') === 'true';
                this.previewMode = 'live'; // 'live' or 'raw'
                this.initializeDarkMode();
                this.bindEvents();
            }

            initializeDarkMode() {
                if (this.isDarkMode) {
                    document.documentElement.classList.add('dark');
                    document.getElementById('darkModeToggle').innerHTML = '<i data-lucide="sun" class="w-5 h-5"></i>';
                } else {
                    document.documentElement.classList.remove('dark');
                    document.getElementById('darkModeToggle').innerHTML = '<i data-lucide="moon" class="w-5 h-5"></i>';
                }
                lucide.createIcons();
            }

            bindEvents() {
                // Tab switching
                document.getElementById('createTab').addEventListener('click', () => this.switchTab('create'));
                document.getElementById('modifyTab').addEventListener('click', () => this.switchTab('modify'));

                // Dark mode toggle
                document.getElementById('darkModeToggle').addEventListener('click', () => this.toggleDarkMode());

                // API key toggle
                document.getElementById('toggleApiKey').addEventListener('click', () => this.toggleApiKeyVisibility());

                // Preview mode toggle
                document.getElementById('rawHtmlToggle').addEventListener('click', () => this.setPreviewMode('raw'));
                document.getElementById('livePreviewToggle').addEventListener('click', () => this.setPreviewMode('live'));

                // Fullscreen preview
                document.getElementById('fullscreenPreview').addEventListener('click', () => this.openFullscreenPreview());
                document.getElementById('closeFullscreen').addEventListener('click', () => this.closeFullscreenPreview());

                // File upload
                document.getElementById('htmlFile').addEventListener('change', (e) => this.handleFileUpload(e));

                // Action buttons
                document.getElementById('testConnection').addEventListener('click', () => this.testConnection());
                document.getElementById('generateHTML').addEventListener('click', () => this.generateHTML());
                document.getElementById('applyChanges').addEventListener('click', () => this.applyChanges());
                document.getElementById('modifyThis').addEventListener('click', () => this.modifyCurrentHtml());
                document.getElementById('clearCurrentHtml').addEventListener('click', () => this.clearCurrentHtmlMode());
                document.getElementById('downloadHtml').addEventListener('click', () => this.downloadHTML());
                document.getElementById('copyToClipboard').addEventListener('click', () => this.copyToClipboard());
                document.getElementById('clearOutput').addEventListener('click', () => this.clearOutput());
                document.getElementById('saveToStorage').addEventListener('click', () => this.saveToStorage());

                // Load saved API key
                const savedApiKey = localStorage.getItem('deepseek_api_key');
                if (savedApiKey) {
                    document.getElementById('apiKey').value = savedApiKey;
                    apiClient.setApiKey(savedApiKey);
                }
            }

            switchTab(tab) {
                this.currentTab = tab;
                
                // Update tab buttons
                document.querySelectorAll('.tab-button').forEach(btn => {
                    btn.classList.remove('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
                    btn.classList.add('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-300');
                });
                
                // Update tab content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });

                if (tab === 'create') {
                    document.getElementById('createTab').classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
                    document.getElementById('createTab').classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-300');
                    document.getElementById('createContent').classList.add('active');
                } else {
                    document.getElementById('modifyTab').classList.add('border-blue-500', 'text-blue-600', 'dark:text-blue-400');
                    document.getElementById('modifyTab').classList.remove('border-transparent', 'text-gray-500', 'hover:text-gray-700', 'dark:text-gray-400', 'dark:hover:text-gray-300');
                    document.getElementById('modifyContent').classList.add('active');
                }
            }

            toggleDarkMode() {
                this.isDarkMode = !this.isDarkMode;
                localStorage.setItem('darkMode', this.isDarkMode);
                this.initializeDarkMode();
            }

            toggleApiKeyVisibility() {
                const apiKeyInput = document.getElementById('apiKey');
                const toggleButton = document.getElementById('toggleApiKey');
                
                if (apiKeyInput.type === 'password') {
                    apiKeyInput.type = 'text';
                    toggleButton.innerHTML = '<i data-lucide="eye-off" class="w-4 h-4"></i>';
                } else {
                    apiKeyInput.type = 'password';
                    toggleButton.innerHTML = '<i data-lucide="eye" class="w-4 h-4"></i>';
                }
                lucide.createIcons();
            }

            setPreviewMode(mode) {
                this.previewMode = mode;
                const previewFrame = document.getElementById('previewFrame');
                const rawHtmlView = document.getElementById('rawHtmlView');
                const liveToggle = document.getElementById('livePreviewToggle');
                const rawToggle = document.getElementById('rawHtmlToggle');

                if (mode === 'raw') {
                    previewFrame.classList.add('hidden');
                    rawHtmlView.classList.remove('hidden');
                    rawToggle.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300');
                    rawToggle.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                    liveToggle.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300');
                    liveToggle.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                } else {
                    previewFrame.classList.remove('hidden');
                    rawHtmlView.classList.add('hidden');
                    liveToggle.classList.add('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300');
                    liveToggle.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                    rawToggle.classList.remove('bg-blue-100', 'dark:bg-blue-900', 'text-blue-700', 'dark:text-blue-300');
                    rawToggle.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
                }
            }

            openFullscreenPreview() {
                console.log('Fullscreen requested. currentHtml:', currentHtml ? currentHtml.length + ' chars' : 'null/empty');
                
                if (!currentHtml || !currentHtml.trim()) {
                    console.log('No HTML available for fullscreen');
                    alert('No HTML content to preview. Please generate HTML first.');
                    return;
                }

                // Always use modal fullscreen for better compatibility
                this.openModalFullscreen();
            }

            enterBrowserFullscreen() {
                // Create a dedicated fullscreen container
                const fullscreenContainer = document.createElement('div');
                fullscreenContainer.id = 'trueFullscreenContainer';
                fullscreenContainer.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: white;
                    z-index: 9999;
                    display: flex;
                    flex-direction: column;
                `;

                // Create header with close button
                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 10px 20px;
                    background: #f3f4f6;
                    border-bottom: 1px solid #e5e7eb;
                `;

                const title = document.createElement('h3');
                title.textContent = 'Full Screen Preview';
                title.style.cssText = 'margin: 0; font-size: 16px; font-weight: 600; color: #374151;';

                const closeButton = document.createElement('button');
                closeButton.innerHTML = '✕';
                closeButton.style.cssText = `
                    background: none;
                    border: none;
                    font-size: 20px;
                    cursor: pointer;
                    color: #6b7280;
                    padding: 5px 10px;
                    border-radius: 4px;
                `;
                closeButton.addEventListener('click', () => this.exitFullscreen());

                header.appendChild(title);
                header.appendChild(closeButton);

                // Create iframe container
                const iframeContainer = document.createElement('div');
                iframeContainer.style.cssText = 'flex: 1; overflow: hidden;';

                const iframe = document.createElement('iframe');
                iframe.style.cssText = 'width: 100%; height: 100%; border: none;';
                iframe.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups';

                iframeContainer.appendChild(iframe);
                fullscreenContainer.appendChild(header);
                fullscreenContainer.appendChild(iframeContainer);
                document.body.appendChild(fullscreenContainer);

                // Load content into iframe
                try {
                    if (iframe.contentDocument || iframe.contentWindow) {
                        const doc = iframe.contentDocument || iframe.contentWindow.document;
                        doc.open();
                        doc.write(currentHtml);
                        doc.close();
                    } else {
                        iframe.srcdoc = currentHtml;
                    }
                } catch (error) {
                    console.error('Fullscreen preview failed:', error);
                    iframe.srcdoc = currentHtml;
                }

                // Enter browser fullscreen
                const requestFullscreen = fullscreenContainer.requestFullscreen || 
                                        fullscreenContainer.webkitRequestFullscreen || 
                                        fullscreenContainer.mozRequestFullScreen || 
                                        fullscreenContainer.msRequestFullscreen;

                if (requestFullscreen) {
                    requestFullscreen.call(fullscreenContainer);
                }

                // Handle fullscreen exit
                const handleFullscreenChange = () => {
                    if (!document.fullscreenElement && !document.webkitFullscreenElement && 
                        !document.mozFullScreenElement && !document.msFullscreenElement) {
                        this.exitFullscreen();
                    }
                };

                document.addEventListener('fullscreenchange', handleFullscreenChange);
                document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
                document.addEventListener('mozfullscreenchange', handleFullscreenChange);
                document.addEventListener('MSFullscreenChange', handleFullscreenChange);

                // Store cleanup function
                this.fullscreenCleanup = () => {
                    document.removeEventListener('fullscreenchange', handleFullscreenChange);
                    document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
                    document.removeEventListener('MSFullscreenChange', handleFullscreenChange);
                };

                // Add ESC key handler
                this.escKeyHandler = (e) => {
                    if (e.key === 'Escape') {
                        this.exitFullscreen();
                    }
                };
                document.addEventListener('keydown', this.escKeyHandler);
            }

            exitFullscreen() {
                // Exit browser fullscreen
                const exitFullscreen = document.exitFullscreen || 
                                     document.webkitExitFullscreen || 
                                     document.mozCancelFullScreen || 
                                     document.msExitFullscreen;

                if (exitFullscreen) {
                    exitFullscreen.call(document);
                }

                // Remove fullscreen container
                const container = document.getElementById('trueFullscreenContainer');
                if (container) {
                    container.remove();
                }

                // Cleanup event listeners
                if (this.fullscreenCleanup) {
                    this.fullscreenCleanup();
                    this.fullscreenCleanup = null;
                }

                if (this.escKeyHandler) {
                    document.removeEventListener('keydown', this.escKeyHandler);
                    this.escKeyHandler = null;
                }
            }

            openModalFullscreen() {
                const modal = document.getElementById('fullscreenModal');
                const fullscreenFrame = document.getElementById('fullscreenFrame');
                
                if (currentHtml && currentHtml.trim()) {
                    try {
                        // Always use srcdoc for better compatibility
                        fullscreenFrame.srcdoc = currentHtml;
                    } catch (error) {
                        console.error('Fullscreen preview failed:', error);
                        alert('Failed to load fullscreen preview');
                        return;
                    }
                }
                
                modal.classList.remove('hidden');
                
                // Focus on close button for keyboard navigation
                setTimeout(() => {
                    document.getElementById('closeFullscreen').focus();
                }, 100);
            }

            closeFullscreenPreview() {
                document.getElementById('fullscreenModal').classList.add('hidden');
            }

            handleFileUpload(event) {
                const file = event.target.files[0];
                if (file && file.type === 'text/html') {
                    // Clear current HTML mode when uploading file
                    this.clearCurrentHtmlMode();
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        currentUploadedHtml = e.target.result;
                        document.getElementById('uploadedFile').classList.remove('hidden');
                        document.getElementById('fileName').textContent = file.name;
                    };
                    reader.readAsText(file);
                }
            }

            modifyCurrentHtml() {
                if (!currentHtml || !currentHtml.trim()) {
                    alert('No generated HTML to modify');
                    return;
                }

                // Set up modify mode with current HTML
                usingGeneratedHtml = true;
                currentUploadedHtml = currentHtml;
                
                // Switch to modify tab
                this.switchTab('modify');
                
                // Show current HTML status
                document.getElementById('currentHtmlStatus').classList.remove('hidden');
                document.getElementById('uploadSection').style.display = 'none';
                
                // Clear uploaded file display
                document.getElementById('uploadedFile').classList.add('hidden');
                document.getElementById('htmlFile').value = '';
                
                // Focus on modification instructions
                document.getElementById('modifyInstructions').focus();
                
                // Re-initialize lucide icons
                lucide.createIcons();
            }

            clearCurrentHtmlMode() {
                usingGeneratedHtml = false;
                currentUploadedHtml = '';
                
                // Hide current HTML status
                document.getElementById('currentHtmlStatus').classList.add('hidden');
                document.getElementById('uploadSection').style.display = 'block';
                
                // Clear modification instructions
                document.getElementById('modifyInstructions').value = '';
                
                // Re-initialize lucide icons
                lucide.createIcons();
            }

            updateConnectionStatus(isConnected) {
                const statusElement = document.getElementById('connectionStatus');
                if (isConnected) {
                    statusElement.innerHTML = `
                        <div class="w-2 h-2 bg-green-500 rounded-full"></div>
                        <span class="text-sm text-gray-500 dark:text-gray-400">Connected</span>
                    `;
                } else {
                    statusElement.innerHTML = `
                        <div class="w-2 h-2 bg-red-500 rounded-full"></div>
                        <span class="text-sm text-gray-500 dark:text-gray-400">Disconnected</span>
                    `;
                }
            }

            async testConnection() {
                const apiKey = document.getElementById('apiKey').value.trim();
                if (!apiKey) {
                    alert('Please enter your DeepSeek API key');
                    return;
                }

                apiClient.setApiKey(apiKey);
                const isConnected = await apiClient.testConnection();
                this.updateConnectionStatus(isConnected);
                
                if (isConnected) {
                    alert('Connection successful!');
                } else {
                    alert('Connection failed. Please check your API key.');
                }
            }

            async generateHTML() {
                const requirements = document.getElementById('createRequirements').value.trim();
                const apiKey = document.getElementById('apiKey').value.trim();

                if (!apiKey) {
                    alert('Please enter your DeepSeek API key');
                    return;
                }

                if (!requirements) {
                    alert('Please describe the HTML application you want to create');
                    return;
                }

                apiClient.setApiKey(apiKey);

                try {
                    const creationPrompt = await fetch('./prompts/creation-prompt.txt').then(r => r.text());
                    const messages = [
                        { role: 'system', content: creationPrompt },
                        { role: 'user', content: requirements }
                    ];

                    streamRenderer.startStream();
                    document.getElementById('generateHTML').disabled = true;

                    await apiClient.streamRequest(
                        messages,
                        (chunk) => streamRenderer.addChunk(chunk),
                        () => {
                            streamRenderer.endStream();
                            document.getElementById('generateHTML').disabled = false;
                        },
                        (error) => {
                            console.error('Generation failed:', error);
                            alert('Failed to generate HTML. Please check your connection and try again.');
                            streamRenderer.endStream();
                            document.getElementById('generateHTML').disabled = false;
                        }
                    );
                } catch (error) {
                    console.error('Generation failed:', error);
                    alert('Failed to generate HTML. Please check your connection and try again.');
                    document.getElementById('generateHTML').disabled = false;
                }
            }

            async applyChanges() {
                const instructions = document.getElementById('modifyInstructions').value.trim();
                const apiKey = document.getElementById('apiKey').value.trim();

                if (!apiKey) {
                    alert('Please enter your DeepSeek API key');
                    return;
                }

                if (!currentUploadedHtml) {
                    alert('Please upload an HTML file first');
                    return;
                }

                if (!instructions) {
                    alert('Please provide modification instructions');
                    return;
                }

                apiClient.setApiKey(apiKey);

                try {
                    const modificationPrompt = await fetch('./prompts/modify-prompt.txt').then(r => r.text());
                    const messages = [
                        { role: 'system', content: modificationPrompt },
                        { role: 'user', content: `HTML file to modify:\n\n${currentUploadedHtml}\n\nModification instructions:\n${instructions}` }
                    ];

                    streamRenderer.startStream();
                    document.getElementById('applyChanges').disabled = true;

                    let modificationResponse = '';
                    await apiClient.streamRequest(
                        messages,
                        (chunk) => {
                            modificationResponse += chunk;
                            streamRenderer.addChunk(chunk);
                        },
                        () => {
                            // Parse search/replace blocks and apply changes
                            const blocks = htmlProcessor.parseSearchReplaceBlocks(modificationResponse);
                            if (blocks.length > 0) {
                                const result = htmlProcessor.applyChanges(currentUploadedHtml, blocks);
                                currentHtml = result.html;
                                
                                // Display the changes
                                htmlProcessor.displaySearchReplaceBlocks(blocks);
                                
                                // Update preview with modified HTML
                                streamRenderer.content = currentHtml;
                                streamRenderer.updatePreview();
                                
                                alert(`Applied ${result.appliedChanges} out of ${result.totalBlocks} changes`);
                            } else {
                                alert('No search/replace blocks found in the response');
                            }
                            
                            streamRenderer.endStream();
                            document.getElementById('applyChanges').disabled = false;
                        },
                        (error) => {
                            console.error('Modification failed:', error);
                            alert('Failed to apply changes. Please check your connection and try again.');
                            streamRenderer.endStream();
                            document.getElementById('applyChanges').disabled = false;
                        }
                    );
                } catch (error) {
                    console.error('Modification failed:', error);
                    alert('Failed to apply changes. Please check your connection and try again.');
                    document.getElementById('applyChanges').disabled = false;
                }
            }

            downloadHTML() {
                if (!currentHtml || !currentHtml.trim()) {
                    alert('No HTML to download. Please generate HTML first.');
                    return;
                }

                const blob = new Blob([currentHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async copyToClipboard() {
                if (!currentHtml || !currentHtml.trim()) {
                    alert('No HTML to copy. Please generate HTML first.');
                    return;
                }

                try {
                    await navigator.clipboard.writeText(currentHtml);
                    alert('HTML copied to clipboard');
                } catch (error) {
                    console.error('Copy failed:', error);
                    alert('Failed to copy to clipboard');
                }
            }

            clearOutput() {
                currentHtml = '';
                streamRenderer.clear();
                // Clear modify mode if using generated HTML
                if (usingGeneratedHtml) {
                    this.clearCurrentHtmlMode();
                }
                // Button will be disabled by streamRenderer.clear()
            }

            saveToStorage() {
                if (!currentHtml) {
                    alert('No HTML to save');
                    return;
                }

                const timestamp = new Date().toISOString();
                const key = `deepseek_html_${timestamp}`;
                
                try {
                    localStorage.setItem(key, currentHtml);
                    alert('HTML saved to browser storage');
                } catch (error) {
                    console.error('Save failed:', error);
                    alert('Failed to save to storage');
                }
            }
        }

        // Initialize application
        document.addEventListener('DOMContentLoaded', () => {
            apiClient = new APIClient();
            streamRenderer = new StreamRenderer(
                document.getElementById('streamOutput'),
                document.getElementById('characterCount')
            );
            htmlProcessor = new HTMLProcessor();
            uiManager = new UIManager();
            
            console.log('HTMLForge initialized - Ready to forge amazing HTML applications!');
        });
    </script>
</body>
</html>